Title of the problem is: Potential XSS Vulnerability. Here is the description of the problem: The ItemDetailsModal.tsx file renders user-provided data such as item name, description, type, location, and quantity directly in the UI without any sanitization, which can lead to XSS attacks if malicious data is entered.
And here are the codes where this problem is appearing:
app/(tabs)/inventory.tsx:
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  FlatList,
  Platform,
  StatusBar,
} from "react-native";
  useSharedValue,
  useAnimatedScrollHandler,
  interpolateColor,
} from "react-native-reanimated";
  horizontalScale,
  verticalScale,
  moderateScale,
} from "@/constants/responsive";

type CategoryType = "Type" | "Location";

export default function InventoryScreen() {
  const [categoryType, setCategoryType] = useState<CategoryType>("Type");
  const [isSelecting, setIsSelecting] = useState(false);
  const [selectedItems, setSelectedItems] = useState<string[]>([]);
  const [modalVisible, setModalVisible] = useState(false);
  const [addNewModalVisible, setAddNewModalVisible] = useState(false);
  const [selectedItemDetails, setSelectedItemDetails] =
    useState<InventoryItem | null>(null);
  const [inventoryItems, setInventoryItems] = useState<InventoryItem[]>(
    inventoryData.items
  );
  const { setTotalItemCount } = useInventory();

  const toggleCategoryType = () => {
    setCategoryType((prev) => (prev === "Type" ? "Location" : "Type"));
  };

  const toggleSelectMode = () => {
    setIsSelecting((prev) => !prev);
    setSelectedItems([]);
  };

  useEffect(() => {
    const count = inventoryItems.length;
    setTotalItemCount(count);
  }, [inventoryItems, setTotalItemCount]);

  const toggleItemSelection = (itemId: string) => {
    setSelectedItems((prev) =>
      prev.includes(itemId)
        ? prev.filter((id) => id !== itemId)
        : [...prev, itemId]
    );
  };

  const updateItem = (updatedItem: InventoryItem) => {
    setInventoryItems((prev) =>
      prev.map((item) => (item.id === updatedItem.id ? updatedItem : item))
    );
    setSelectedItemDetails(updatedItem);
  };

  const handleItemPress = (item: InventoryItem) => {
    if (isSelecting) {
      toggleItemSelection(item.id);
    } else {
      setSelectedItemDetails(item);
      setModalVisible(true);
    }
  };

  const removeSelectedItems = () => {
    setInventoryItems((prev) =>
      prev.filter((item) => !selectedItems.includes(item.id))
    );
    setSelectedItems([]);
    setIsSelecting(false);
  };

  const removeItem = (itemId: string) => {
    setInventoryItems((prev) => prev.filter((item) => item.id !== itemId));
    setModalVisible(false);
  };
  const handleAddNewItem = (newItem: InventoryItem) => {
    setInventoryItems((prev) => [...prev, newItem]);
    setAddNewModalVisible(false);
  };
  const groupedItems = inventoryItems.reduce((acc, item) => {
    const key = categoryType === "Type" ? item.type : item.location;
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(item);
    return acc;
  }, {} as Record<string, InventoryItem[]>);

  const groupedItemsArray = Object.entries(groupedItems);

  const scrollY = useSharedValue(0);
  const headerBackgroundColor = useSharedValue(Colors.light.background);

  const scrollHandler = useAnimatedScrollHandler({
    onScroll: (event) => {
      scrollY.value = event.contentOffset.y;
      headerBackgroundColor.value = interpolateColor(
        scrollY.value,
        [0, 50],
        [Colors.light.background, Colors.light.background]
      );
    },
  });

  const renderCategorySection = useCallback(
    ({ item }: { item: [string, InventoryItem[]] }) => {
      const [category, items] = item;
      return (
        <CategorySection
          category={category}
          items={items}
          onItemPress={handleItemPress}
          isSelecting={isSelecting}
          selectedItems={selectedItems}
        />
      );
    },
    [isSelecting, selectedItems, handleItemPress]
  );

  return (
    <SafeAreaView style={styles.safeArea}>
      <View style={styles.container}>
        <YummyLogo style={styles.logo} />
        <Text style={styles.title}>Inventory</Text>
        <Text style={styles.subtitle}>Add or modify your Groceries</Text>

        <View style={styles.buttonContainer}>
          <CategoryButton
            onPress={toggleCategoryType}
            categoryType={categoryType}
          />
          <AddNewButton onPress={() => setAddNewModalVisible(true)} />
          <SelectButton onPress={toggleSelectMode} isSelecting={isSelecting} />
        </View>

        <View style={styles.listContainer}>
          <TopBlur color={headerBackgroundColor} />
          <Animated.FlatList
            data={groupedItemsArray}
            renderItem={renderCategorySection}
            keyExtractor={(item) => item[0]}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            onScroll={scrollHandler}
            scrollEventThrottle={16}
          />
          <LinearGradient
            colors={["rgba(255, 255, 255, 0)", Colors.light.background]}
            style={styles.bottomGradient}
          />
        </View>

        {isSelecting && <RemoveButton onPress={removeSelectedItems} />}

        <ItemDetailsModal
          visible={modalVisible}
          item={selectedItemDetails}
          onClose={() => setModalVisible(false)}
          onUpdate={updateItem}
          onRemove={removeItem}
        />
        <AddNewModal
          isVisible={addNewModalVisible}
          onClose={() => setAddNewModalVisible(false)}
          onAddItem={handleAddNewItem}
        />
      </View>
    </SafeAreaView>
  );
}



components/inventory/ItemDetailsModal.tsx:
  Modal,
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  TextInput,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
  horizontalScale,
  verticalScale,
  moderateScale,
} from "@/constants/responsive";
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
  runOnJS,
} from "react-native-reanimated";
  InventoryItemDetailsModalProps,
  InventoryItem,
  InfoItemProps,
} from "@/types";

export const ItemDetailsModal: React.FC<InventoryItemDetailsModalProps> = ({
  visible,
  item,
  onClose,
  onUpdate,
  onRemove,
}) => {
  const [editedItem, setEditedItem] = useState<InventoryItem | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);

  const slideAnim = useSharedValue(horizontalScale(390));

  useEffect(() => {
    if (visible) {
      setModalVisible(true);
      slideAnim.value = withTiming(0, {
        duration: 300,
        easing: Easing.bezier(0.25, 0.1, 0.25, 1),
      });
    } else {
      slideAnim.value = withTiming(
        horizontalScale(390),
        {
          duration: 300,
          easing: Easing.bezier(0.25, 0.1, 0.25, 1),
        },
        (finished) => {
          if (finished) {
            runOnJS(setModalVisible)(false);
          }
        }
      );
    }
  }, [visible]);

  useEffect(() => {
    setEditedItem(item);
    setIsEditing(false);
  }, [item]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateX: slideAnim.value }],
  }));

  const handleEdit = () => setIsEditing(true);

  const handleSave = () => {
    if (editedItem) {
      onUpdate(editedItem);
      setIsEditing(false);
    }
  };

  const handleRemove = () => {
    if (item) {
      onRemove(item.id);
    }
  };

  const handleInputChange = (field: keyof InventoryItem, value: string) => {
    setEditedItem((prev) => {
      if (!prev) return null;
      if (field === "quantity") {
        return { ...prev, [field]: parseInt(value) || 0 };
      }
      return { ...prev, [field]: value };
    });
  };

  if (!item) return null;

  return (
    <Modal
      transparent={true}
      visible={modalVisible}
      animationType="none"
      onRequestClose={onClose}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.modalOverlay}
      >
        <Animated.View style={[styles.modalContent, animatedStyle]}>
          <ScrollView contentContainerStyle={styles.scrollViewContent}>
            <TouchableOpacity style={styles.backButton} onPress={onClose}>
              <Text style={styles.backButtonText}>‚Üê</Text>
            </TouchableOpacity>
            <View style={styles.emojiContainer}>
              <Text style={styles.emoji}>{item.emoji}</Text>
            </View>
            <TextInput
              style={[styles.nameInput, isEditing && styles.editingInput]}
              value={editedItem?.name}
              onChangeText={(text) => handleInputChange("name", text)}
              editable={isEditing}
              onSubmitEditing={handleSave}
            />
            <TextInput
              style={[
                styles.descriptionInput,
                isEditing && styles.editingInput,
              ]}
              value={editedItem?.description}
              onChangeText={(text) => handleInputChange("description", text)}
              multiline
              editable={isEditing}
              onSubmitEditing={handleSave}
            />
            <View style={styles.infoContainer}>
              <InfoItem
                label="Type"
                value={editedItem?.type || ""}
                isEditing={isEditing}
                onChangeText={(text: string) => handleInputChange("type", text)}
                onSubmitEditing={handleSave}
              />
              <InfoItem
                label="Location"
                value={editedItem?.location || ""}
                isEditing={isEditing}
                onChangeText={(text: string) =>
                  handleInputChange("location", text)
                }
                onSubmitEditing={handleSave}
              />
              <InfoItem
                label="Quantity"
                value={editedItem?.quantity.toString() || "0"}
                isEditing={isEditing}
                onChangeText={(text: string) =>
                  handleInputChange("quantity", text)
                }
                onSubmitEditing={handleSave}
                keyboardType="numeric"
              />
            </View>
            <TouchableOpacity
              style={styles.editButton}
              onPress={isEditing ? handleSave : handleEdit}
            >
              <LinearGradient
                colors={Gradients.main}
                start={{ x: 0, y: 0 }}
                end={{ x: 1, y: 0 }}
                style={styles.editButtonGradient}
              >
                <Text style={styles.editButtonText}>
                  {isEditing ? "Save Changes" : "Edit this Item"}
                </Text>
              </LinearGradient>
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.removeButton}
              onPress={handleRemove}
            >
              <Text style={styles.removeButtonText}>Remove this Item</Text>
            </TouchableOpacity>
          </ScrollView>
        </Animated.View>
      </KeyboardAvoidingView>
    </Modal>
  );
};

const InfoItem: React.FC<InfoItemProps> = ({
  label,
  value,
  isEditing,
  onChangeText,
  onSubmitEditing,
  keyboardType = "default",
}) => (
  <View style={styles.infoItem}>
    <Text style={styles.infoLabel}>{label}:</Text>
    <TextInput
      style={[
        styles.infoInput,
        isEditing ? styles.editingInput : styles.infoValue,
      ]}
      value={value}
      onChangeText={onChangeText}
      editable={isEditing}
      onSubmitEditing={onSubmitEditing}
      keyboardType={keyboardType}
    />
  </View>
);



